<!DOCTYPE html><html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mr.猿</title><link rel="stylesheet" href="/css/pure-min.css">
<link rel="stylesheet" href="/css/grids-responsive-min.css">
<link rel="stylesheet" href="/css/style.css"></head><body><div id="layout" class="pure-g"><div class="sidebar pure-u-1 pure-u-md-1-4"><div class="header"><h1 class="brand-title"><a href="/">Mr.猿</a></h1><h2 class="brand-tagline">淡观山水闲看月，只读诗书不念愁。</h2><nav class="nav"><ul class="nav-list"><li class="nav-item"><a href="/archives" class="pure-button">文章列表</a></li><li class="nav-item"><a href="/about" class="pure-button">关于我</a></li></ul></nav></div></div><div class="content pure-u-1 pure-u-md-3-4"><div class="posts"><div class="post"><div class="post-header"><img height="48" width="48" src="https://www.gravatar.com/avatar/43fdda7ad74de17ca7bf9194f3976497?s=48" class="post-avatar"/><h2 class="post-title">存储管理之页式、段式、段页式存储</h2><p class="post-meta"><span class="post-date"><i class="icon-clock"></i>2018-01-20 22:57</span><span class="post-tags"><i class="icon-tags"></i><a href="/tags/操作系统/" class="post-tag">操作系统</a></span></p></div><div class="post-content"><p>首先看一下“基本的存储分配方式”种类：<br><img src="/2018/01/20/存储管理之页式、段式、段页式存储/p1.png" alt="图1"></p>
<h2 id="1-离散分配方式的出现"><a href="#1-离散分配方式的出现" class="headerlink" title="1.  离散分配方式的出现"></a>1.  离散分配方式的出现</h2><p>由于连续分配方式会形成许多内存碎片，虽可通过“紧凑”功能将碎片合并，但会付出很大开销。于是出现离散分配方式：将一个进程直接分散地装入到许多不相邻的内存分区中。<br> 下面主要介绍“<b>离散分配</b>”三种方式的基本原理以及步骤：</p>
<h2 id="2-基本分页存储"><a href="#2-基本分页存储" class="headerlink" title="2.  基本分页存储"></a>2.  基本分页存储</h2><h3 id="2-1-步骤"><a href="#2-1-步骤" class="headerlink" title="2.1.       步骤"></a>2.1.       步骤</h3><ul>
<li>逻辑空间等分为页；并从0开始编号</li>
<li>内存空间等分为块，与页面大小相同；从0开始编号<br>分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中。</li>
</ul>
<h3 id="2-2-地址结构"><a href="#2-2-地址结构" class="headerlink" title="2.2.       地址结构"></a>2.2.       地址结构</h3><p>   分两部分：页号、位移量（业内地址）</p>
<p><img src="/2018/01/20/存储管理之页式、段式、段页式存储/p2.png" alt="图2"> </p>
<p>   业内地址的位数可以决定页的大小（如上图每页大小为4K）。<br>逻辑地址=页号&amp;位移量（&amp;号是连接符号，是将页号作为逻辑地址的最高位）</p>
<h3 id="2-3-地址映射（逻辑地址—-gt-物理地址）"><a href="#2-3-地址映射（逻辑地址—-gt-物理地址）" class="headerlink" title="2.3.       地址映射（逻辑地址—&gt;物理地址）"></a>2.3.       地址映射（逻辑地址—&gt;物理地址）</h3><p>如下图所示：（物理地址=块号&amp;块内地址）<br><img src="/2018/01/20/存储管理之页式、段式、段页式存储/p3.png" alt="图3"></p>
<p>因为块的大小=页的大小，所以块内位移量=页内位移量，所以只需求出块号即可：</p>
<p><img src="/2018/01/20/存储管理之页式、段式、段页式存储/p4.png" alt="图4"></p>
<p>如何求块号呢？页表来帮你<br>页表：<br><img src="/2018/01/20/存储管理之页式、段式、段页式存储/p5.png" alt="图5"></p>
<p>给定一个逻辑地址和页面大小，如何计算物理地址？</p>
<h6 id="1-根据页面大小可计算出页内地址的位数"><a href="#1-根据页面大小可计算出页内地址的位数" class="headerlink" title="1)       根据页面大小可计算出页内地址的位数"></a>1)       根据页面大小可计算出页内地址的位数</h6><h6 id="2-页内地址位数结合逻辑地址计算出页内地址（即，块内地址）和页号"><a href="#2-页内地址位数结合逻辑地址计算出页内地址（即，块内地址）和页号" class="headerlink" title="2)       页内地址位数结合逻辑地址计算出页内地址（即，块内地址）和页号"></a>2)       页内地址位数结合逻辑地址计算出页内地址（即，块内地址）和页号</h6><h6 id="3-页号结合页表，即可得出块号"><a href="#3-页号结合页表，即可得出块号" class="headerlink" title="3)       页号结合页表，即可得出块号"></a>3)       页号结合页表，即可得出块号</h6><h6 id="4-块号-amp-块内地址即可得出物理地址"><a href="#4-块号-amp-块内地址即可得出物理地址" class="headerlink" title="4)       块号&amp;块内地址即可得出物理地址"></a>4)       块号&amp;块内地址即可得出物理地址</h6><h3 id="2-4-地址变换原理及步骤"><a href="#2-4-地址变换原理及步骤" class="headerlink" title="2.4.       地址变换原理及步骤"></a>2.4.       地址变换原理及步骤</h3><p><img src="/2018/01/20/存储管理之页式、段式、段页式存储/p6.png" alt="图6"></p>
<p>请看上图，给出逻辑地址的页号和页内地址，开始进行地址变换：</p>
<h6 id="1-在被调进程的PCB中取出页表始址和页表大小，装入页表寄存器"><a href="#1-在被调进程的PCB中取出页表始址和页表大小，装入页表寄存器" class="headerlink" title="1)       在被调进程的PCB中取出页表始址和页表大小，装入页表寄存器"></a>1)       在被调进程的PCB中取出页表始址和页表大小，装入页表寄存器</h6><h6 id="2-页号与页表寄存器的页表长度比较，若页号大于等于页表长度，发生地址越界中断，停止调用，否则继续"><a href="#2-页号与页表寄存器的页表长度比较，若页号大于等于页表长度，发生地址越界中断，停止调用，否则继续" class="headerlink" title="2)       页号与页表寄存器的页表长度比较，若页号大于等于页表长度，发生地址越界中断，停止调用，否则继续"></a>2)       页号与页表寄存器的页表长度比较，若页号大于等于页表长度，发生地址越界中断，停止调用，否则继续</h6><h6 id="3-由页号结合页表始址求出块号"><a href="#3-由页号结合页表始址求出块号" class="headerlink" title="3)       由页号结合页表始址求出块号"></a>3)       由页号结合页表始址求出块号</h6><h6 id="4-块号-amp-页内地址，即得物理地址"><a href="#4-块号-amp-页内地址，即得物理地址" class="headerlink" title="4)       块号&amp;页内地址，即得物理地址"></a>4)       块号&amp;页内地址，即得物理地址</h6><p>以上即为页式存储的原理及整个过程……</p>
<h2 id="3-基本分段存储"><a href="#3-基本分段存储" class="headerlink" title="3.   基本分段存储"></a>3.   基本分段存储</h2><h4 id="3-1-步骤"><a href="#3-1-步骤" class="headerlink" title="3.1.       步骤"></a>3.1.       步骤</h4><p> 逻辑空间分为若干个段，每个段定义了一组有完整逻辑意义的信息（如主程序<b>Main()</b>），如：</p>
<p><img src="/2018/01/20/存储管理之页式、段式、段页式存储/p7.png" alt="图7"></p>
<p>内存空间为每个段分配一个连续的分区</p>
<p>段的长度由相应的逻辑信息组的长度决定，因而各段长度不等，引入分段存储管理方式的目的主要是为了满足用户（程序员）在编程和使用上多方面的要求。<br>要注重理解，完整的逻辑意义信息，就是说将程序分页时，页的大小是固定的，只根据页面大小大小死生生的将程序切割开；而分段时比较灵活，只有一段程序有了完整的意义才将这一段切割开。（例如将一个人每隔50厘米切割一段，即为分页；而将一个人分割为头部、身体、腿部（有完整逻辑意义）三段，即为分段）</p>
<h4 id="3-2-地址结构"><a href="#3-2-地址结构" class="headerlink" title="3.2.       地址结构"></a>3.2.       地址结构</h4><p>  分两部分：段号、位移量（段内地址）<br><img src="/2018/01/20/存储管理之页式、段式、段页式存储/p8.png" alt="图8"></p>
<p> 段内地址的位数可以决定段的大小<br> 逻辑地址=段号&amp;段内地址（&amp;号是连接符号，是将段号作为逻辑地址的最高位）</p>
<h4 id="3-3-地址映射（逻辑地址—-gt-物理地址）"><a href="#3-3-地址映射（逻辑地址—-gt-物理地址）" class="headerlink" title="3.3.       地址映射（逻辑地址—&gt;物理地址）"></a>3.3.       地址映射（逻辑地址—&gt;物理地址）</h4><p>如下图所示：（物理地址=基址+段内地址）（注意为+号，而不是&amp;号）</p>
<p><img src="/2018/01/20/存储管理之页式、段式、段页式存储/p9.png" alt="图9"></p>
<p>由上图可知若想求物理地址，只需求出基址即可：</p>
<p>如何求基址呢？段表来帮你<br>段表：<br><img src="/2018/01/20/存储管理之页式、段式、段页式存储/p10.png" alt="图10"></p>
<p>求基址的过程与页式存储中求块号的过程原理相同，这里需要注意的是，物理地址是基址+段内地址，而不是基址&amp;段内地址，由逻辑地址得到段号、段内地址，再根据段号和段表求出基址，再由基址+段内地址即可得物理地址。</p>
<h4 id="3-4-地址变换原理及步骤"><a href="#3-4-地址变换原理及步骤" class="headerlink" title="3.4.       地址变换原理及步骤"></a>3.4.       地址变换原理及步骤</h4><p><img src="/2018/01/20/存储管理之页式、段式、段页式存储/p11.png" alt="图11"></p>
<p>请看上图，给出逻辑地址的段号和段内地址，开始进行地址变换：</p>
<h6 id="1-在被调进程的PCB中取出段表始址和段表长度，装入控制寄存器"><a href="#1-在被调进程的PCB中取出段表始址和段表长度，装入控制寄存器" class="headerlink" title="1)       在被调进程的PCB中取出段表始址和段表长度，装入控制寄存器"></a>1)       在被调进程的PCB中取出段表始址和段表长度，装入控制寄存器</h6><h6 id="2-段号与控制寄存器的页表长度比较，若页号大于等于段表长度，发生地址越界中断，停止调用，否则继续"><a href="#2-段号与控制寄存器的页表长度比较，若页号大于等于段表长度，发生地址越界中断，停止调用，否则继续" class="headerlink" title="2)       段号与控制寄存器的页表长度比较，若页号大于等于段表长度，发生地址越界中断，停止调用，否则继续"></a>2)       段号与控制寄存器的页表长度比较，若页号大于等于段表长度，发生地址越界中断，停止调用，否则继续</h6><h6 id="3-由段号结合段表始址求出基址"><a href="#3-由段号结合段表始址求出基址" class="headerlink" title="3)       由段号结合段表始址求出基址"></a>3)       由段号结合段表始址求出基址</h6><h6 id="4-基址-段内地址，即得物理地址"><a href="#4-基址-段内地址，即得物理地址" class="headerlink" title="4)       基址+段内地址，即得物理地址"></a>4)       基址+段内地址，即得物理地址</h6><p>以上即为段式存储的原理及整个过程……</p>
<p>分页和分段的主要区别：<br><img src="/2018/01/20/存储管理之页式、段式、段页式存储/p12.png" alt="图12"></p>
<h2 id="4-基本段页式存储"><a href="#4-基本段页式存储" class="headerlink" title="4.  基本段页式存储"></a>4.  基本段页式存储</h2><h4 id="4-1-步骤"><a href="#4-1-步骤" class="headerlink" title="4.1.       步骤"></a>4.1.       步骤</h4><p>³ 用户程序先分段，每个段内部再分页（内部原理同基本的分页、分段相同）<br><img src="/2018/01/20/存储管理之页式、段式、段页式存储/p13.png" alt="图13"></p>
<h4 id="4-2-地址结构"><a href="#4-2-地址结构" class="headerlink" title="4.2.       地址结构"></a>4.2.       地址结构</h4><p>   分三部分：段号、段内页号、页内地址</p>
<p><img src="/2018/01/20/存储管理之页式、段式、段页式存储/p14.png" alt="图14"></p>
<h4 id="4-3-地址映射（逻辑地址—-gt-物理地址）"><a href="#4-3-地址映射（逻辑地址—-gt-物理地址）" class="headerlink" title="4.3.       地址映射（逻辑地址—&gt;物理地址）"></a>4.3.       地址映射（逻辑地址—&gt;物理地址）</h4><p> <b>逻辑地址</b>——&gt;段号、段内页号、业内地址<br> <b>段表寄存器</b>—-&gt;段表始址<br> <b>段号+段表始址</b>——&gt;页表始址<br> <b>页表始址+段内页号</b>——&gt;存储块号<br> <b>块号+页内地址</b>——&gt;物理地址</p>
<p><img src="/2018/01/20/存储管理之页式、段式、段页式存储/p15.png" alt="图15"></p>
<h4 id="4-4-地址变换原理及步骤"><a href="#4-4-地址变换原理及步骤" class="headerlink" title="4.4.       地址变换原理及步骤"></a>4.4.       地址变换原理及步骤</h4><p><img src="/2018/01/20/存储管理之页式、段式、段页式存储/p16.png" alt="图16"><br>请看上图，给出逻辑地址的段号、页号、页内地址，开始进行地址变换：</p>
<h6 id="1-在被调进程的PCB中取出段表始址和段表长度，装入段表寄存器"><a href="#1-在被调进程的PCB中取出段表始址和段表长度，装入段表寄存器" class="headerlink" title="1)       在被调进程的PCB中取出段表始址和段表长度，装入段表寄存器"></a>1)       在被调进程的PCB中取出段表始址和段表长度，装入段表寄存器</h6><h6 id="2-段号与控制寄存器的页表长度比较，若页号大于等于段表长度，发生地址越界中断，停止调用，否则继续-1"><a href="#2-段号与控制寄存器的页表长度比较，若页号大于等于段表长度，发生地址越界中断，停止调用，否则继续-1" class="headerlink" title="2)       段号与控制寄存器的页表长度比较，若页号大于等于段表长度，发生地址越界中断，停止调用，否则继续"></a>2)       段号与控制寄存器的页表长度比较，若页号大于等于段表长度，发生地址越界中断，停止调用，否则继续</h6><h6 id="3-由段号结合段表始址求出页表始址和页表大小"><a href="#3-由段号结合段表始址求出页表始址和页表大小" class="headerlink" title="3)       由段号结合段表始址求出页表始址和页表大小"></a>3)       由段号结合段表始址求出页表始址和页表大小</h6><h6 id="4-页号与段表的页表大小比较，若页号大于等于页表大小，发生地址越界中断，停止调用，否则继续"><a href="#4-页号与段表的页表大小比较，若页号大于等于页表大小，发生地址越界中断，停止调用，否则继续" class="headerlink" title="4)       页号与段表的页表大小比较，若页号大于等于页表大小，发生地址越界中断，停止调用，否则继续"></a>4)       页号与段表的页表大小比较，若页号大于等于页表大小，发生地址越界中断，停止调用，否则继续</h6><h6 id="5-由页表始址结合段内页号求出存储块号"><a href="#5-由页表始址结合段内页号求出存储块号" class="headerlink" title="5)       由页表始址结合段内页号求出存储块号"></a>5)       由页表始址结合段内页号求出存储块号</h6><h6 id="6-存储块号-amp-页内地址，即得物理地址"><a href="#6-存储块号-amp-页内地址，即得物理地址" class="headerlink" title="6)       存储块号&amp;页内地址，即得物理地址"></a>6)       存储块号&amp;页内地址，即得物理地址</h6><p><b>以上即为段页式存储的原理及整个过程……<b></b></b></p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.  总结"></a>5.  总结</h2><p>在页式、段式存储管理中，为获得一条指令或数据，须两次访问内存；而段页式则须三次访问内存</p>
</div><nav id="post-nav"><a id="post-nav-newer" href="/2018/01/20/使用Apache-Tile/" class="post-nav-link-wrap"><strong class="post-nav-caption">Newer</strong><div class="post-nav-title">使用Apache-Tile</div></a><a id="post-nav-older" href="/2018/01/15/hello-world/" class="post-nav-link-wrap"><strong class="post-nav-caption">Older</strong><div class="post-nav-title">Hello World</div></a></nav></div></div><div class="footer"><div class="social-link"><a href="http://weibo.com/SiteratorYue" target="_blank"><i class="icon-weibo"></i></a><a href="https://github.com/czy812" target="_blank"><i class="icon-github"></i></a><a href="https://plus.google.com/" target="_blank"><i class="icon-gplus"></i></a><a href="https://twitter.com/" target="_blank"><i class="icon-twitter"></i></a></div><div class="copyright">&copy; 2018 C_yue.
Powered by <a href="http://hexo.io" target="_blank">Hexo</a>
using <a href="https://github.com/saintwinkle/hexo-theme-pure" target="_blank">Pure</a> theme.</div></div></div><script src="/js/script.js"></script></div></body></html>